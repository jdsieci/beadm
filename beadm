#!/bin/bash
set -e

# Linux beadm imprementation based on:
# https://github.com/evan-king/grub2-zfs-be
# https://github.com/vermaden/beadm

if find /lib/modules/$(uname -r)/ -name 'zfs.ko*' -exec false {} +;then
  echo "ERROR: ZFS modules not found"
  exit 1
fi

ROOTFS=$( mount | awk '/ \/ / {print $1}' )

if echo ${ROOTFS} | grep -q -m 1 -E "^/dev/";then
  echo "ERROR: This system does not boot from ZFS pool"
  exit 1
fi

POOL=$( echo ${ROOTFS} | awk -F '/' '{print $1}' )

if [ $( echo ${ROOTFS} | awk -F '/' '{print NF}' ) -lt 3 ];then
  echo "ERROR: This system is not configured for boot environments"
  exit 1
fi

BOOTFS=$( zpool list -H -o bootfs ${POOL} )

if [ -z "${BOOTFS}" -o "${BOOTFS}" = "-" ];then
  echo "ERROR: ZFS boot pool '${POOL}' has unset 'bootfs' property"
  exit 1
fi

if [ -f /usr/local/etc/beadm.conf ]
then
  . /usr/local/etc/beadm.conf
elif [ -f /etc/beadm.conf ]
then
  . /etc/beadm.conf
fi

# update GRUB bootloader instead of FreeBSD's loader(8)
: ${GRUB="YES"}
# GRUB mkconfig command path
: ${GRUBCMD="/usr/sbin/grub2-mkconfig"}
# Grub config path
: ${GRUB_CONFIG="/boot/efi/EFI/fedora/grub.cfg"}

# use other prefix then the 'pool/ROOT/bename' default
: ${BEDS="$( echo ${ROOTFS} | awk -F '/' '{print $2}' )"}


usage() {
  local NAME=${0##*/}
  echo "usage:"
  echo "  ${NAME} activate <beName>"
  echo "  ${NAME} create [-e nonActiveBe | -e beName@snapshot] <beName>"
  echo "  ${NAME} create <beName@snapshot>"
  echo "  ${NAME} destroy [-F] <beName | beName@snapshot>"
  echo "  ${NAME} list [-a] [-s] [-D] [-H]"
  echo "  ${NAME} rename <origBeName> <newBeName>"
  echo "  ${NAME} mount <beName> [mountpoint]"
  echo "  ${NAME} { umount | unmount } [-f] <beName>"
  echo "  ${NAME} version"
  exit 1
}

get_command() {
  if [ "$(type -t "cmd_$1")" = "function" ]; then
    printf "cmd_$1"
  else
    printf "usage"
  fi
}

list_zfs_roots() {
  zfs list -H -o name -s creation | awk -F'/' \
    -v BEROOT=$(get_bebase) \
    'match($0,"^" BEROOT "/.+") {
      print BEROOT "/" $3
    }' | uniq
  return 0
}

# get_current_be: void -> bename
get_current_be() {
    mount | grep " on / " | sed -r "s;^.*/(.*) on / .*;\1;g"
    return 0
}

get_active_be() {
  echo $BOOTFS | sed -r "s;^.*/(.*) on / .*;\1;g"
  return 0
}

get_bebase() {
  printf "%s/%s" $POOL $BEDS
  return 0
}

# snapshot_exists: fullsnapname -> 0|1
snapshot_exists() {
    zfs list -H -o name -t snapshot | grep "^$1$" > /dev/null
    return $?
}

# be_exists: fulldatasetname -> 0|1
be_exists() {
  zfs list -H -o name ${1} 1> /dev/null 2> /dev/null
  return $?
}

# be_isclone: fulldatasetname -> 0|1
be_isclone() { # 1=DATASET
  if zfs list ${1} 1> /dev/null 2> /dev/null;then
    local ORIGIN="$( zfs list -H -o origin ${1} )"
    if [ "${ORIGIN}" = "-" ];then
      # boot environment is not a clone
      return 1
    else
      # boot environment is a clone
      return 0
    fi
  else
    # boot environment does not exist
    return 2
  fi
}

# check if system has a grub.cfg file and update it
update_grub() {
  if [ -e ${GRUB_CONFIG} ];then
    if $GRUBCMD -o ${GRUB_CONFIG} 1> /dev/null 2> /dev/null
    then
      echo "GRUB configuration updated successfully"
      return 0
    else
      echo "WARNING: Failed to update GRUB configuration"
      return 1
    fi
  fi
}

cmd_list() {
  OPTION_a=0
  OPTION_D=0
  OPTION_s=0
  while getopts "aDHs" OPT
  do
    case ${OPT} in
      (a) OPTION_a=1 ;;
      (D) OPTION_D=1 ;;
      (H) OPTION_H=1 ;;
      (s) OPTION_s=1
          OPTION_a=1 ;;
      (*) return usage    ;;
    esac
  done

  LANG=C zfs list -H -t filesystem,snapshot,volume -s creation -o name,used,usedds,usedbysnapshots,usedrefreserv,refer,creation,origin -r | awk -v POOL="${POOL}" \
    -v BEDS="${BEDS}" \
    -v ROOTFS="${ROOTFS}" \
    -v BOOTFS="${BOOTFS}" \
    -v OPTION_a="${OPTION_a}" \
    -v OPTION_D="${OPTION_D}" \
    -v OPTION_H="${OPTION_H}" \
    -v OPTION_s="${OPTION_s}" \
    'function __normalize(VALUE) {
      if(VALUE == "-" || VALUE == 0)
        return 0
      else
        return substr(VALUE, 1, length(VALUE) - 1) * MULTIPLIER[substr(VALUE, length(VALUE))]
    }
    function __get_bename(BENAME) {
      sub(BENAME_BEGINS_WITH "\\/", "", BENAME)
      sub("/.*", "", BENAME)
      return BENAME
    }
    function __header() {
      if(OPTION_a == 1) {
        BE_HEAD = "BE/Dataset/Snapshot"
        printf "%-" FSNAME_LENGTH + 2 "s %-6s %-" MOUNTPOINT_LENGTH "s %6s %s\n", BE_HEAD, "Active", "Mountpoint", "Space", "Created"
      }
      else if(OPTION_H == 1)
        BE_HEAD = ""
      else {
        BE_HEAD = "BE"
        printf "%-" FSNAME_LENGTH "s %-6s %-" MOUNTPOINT_LENGTH "s %6s %s\n", BE_HEAD, "Active", "Mountpoint", "Space", "Created"
      }
    }
    function __active(NAME) {
      ACTIVE = ""
      if(NAME == ROOTFS)
        ACTIVE = ACTIVE "N"
      if(NAME == BOOTFS)
        ACTIVE = ACTIVE "R"
      if(! ACTIVE)
        ACTIVE = "-"
      return ACTIVE
    }
    function __convert_date(DATE) {
      CMD_DATE = "date --date \"" DATE "\" +\"%Y-%m-%d %H:%M\""
      CMD_DATE | getline NEW
      close(CMD_DATE)
      return NEW
    }
    function __show_units(VALUE) {
           if(VALUE < 1024)                {                               UNIT = "K"; }
      else if(VALUE < 1048576)             { VALUE /= 1024;                UNIT = "M"; }
      else if(VALUE < 1073741824)          { VALUE /= 1048576;             UNIT = "G"; }
      else if(VALUE < 1099511627776)       { VALUE /= 1073741824;          UNIT = "T"; }
      else if(VALUE < 1125899906842624)    { VALUE /= 1099511627776;       UNIT = "P"; }
      else if(VALUE < 1152921504606846976) { VALUE /= 1125899906842624;    UNIT = "E"; }
      else                                 { VALUE /= 1152921504606846976; UNIT = "Z"; }
      return sprintf("%.1f%s", VALUE, UNIT)
    }
    BEGIN {
      BENAME_BEGINS_WITH = POOL "/" BEDS
      MULTIPLIER["K"] = 1
      MULTIPLIER["M"] = 1024
      MULTIPLIER["G"] = 1048576
      MULTIPLIER["T"] = 1073741824
      MULTIPLIER["P"] = 1099511627776
      MULTIPLIER["E"] = 1125899906842624
      MULTIPLIER["Z"] = 1152921504606846976
      MOUNTPOINT_LENGTH = 10
      FSNAME_LENGTH = 2
      #Initialize FSNAMES as array
      delete FSNAMES[0]
      CMD_MOUNT="mount"
      while(CMD_MOUNT | getline)
        if($1 ~ "^" BENAME_BEGINS_WITH)
          MOUNTS[$1] = $3
      close(CMD_MOUNT)
      FS = "\\t"
    }
    $1 ~ BENAME_BEGINS_WITH {
      if($1 != BENAME_BEGINS_WITH) {
        FSNAME = $1
        FSNAMES[length(FSNAMES) + 1] = FSNAME
        USED              = __normalize($2)
        USEDBYDATASET     = __normalize($3)
        USEDBYSNAPSHOTS   = __normalize($4)
        USEDREFRESERV     = __normalize($5)
        REFER[FSNAME]     = __normalize($6)
        CREATIONS[FSNAME] = $7
        ORIGINS[FSNAME]   = $8
        if(FSNAME ~ /@/){
          SPACES[FSNAME] = USED
        } 
        else {
          SPACES[FSNAME] = USEDBYDATASET + USEDREFRESERV
          if(OPTION_D == 1)
            SPACES[FSNAME] += USEDBYSNAPSHOTS
          BE = __get_bename(FSNAME)
          if(index(BELIST, BE) == 0)
            BELIST = BELIST " " BE
          MOUNTPOINT = MOUNTS[FSNAME]
          if(MOUNTPOINT) {
            if((OPTION_a == 0 && FSNAME == (BENAME_BEGINS_WITH "/" __get_bename(FSNAME))) || (OPTION_a == 1)) {
              LM = length(MOUNTPOINT)
              if(LM > MOUNTPOINT_LENGTH)
                  MOUNTPOINT_LENGTH = LM
            }
          }
        }
        if(OPTION_a == 1)
          LF = length(FSNAME)
        else if(FSNAME !~ /@/)
          LF = length(__get_bename(FSNAME))
        if(LF > FSNAME_LENGTH)
          FSNAME_LENGTH = LF
      }
    }
    END {
      split(BELIST, BENAMES, " ")
      if(OPTION_s != 1)
        SNAPSHOT_FILTER = "(/[^@]*)?$"
      __header()
      for(I = 1; I <= length(BENAMES); I++) {
        BENAME = BENAMES[I]
        if(OPTION_a == 1) {
          printf "\n"
          print BENAME
          for(J = 1; J <= length(FSNAMES); J++) {
            FSNAME = FSNAMES[J]
            if(FSNAME ~ "^" BENAME_BEGINS_WITH "/" BENAME SNAPSHOT_FILTER) {
              ACTIVE = __active(FSNAME)
              MOUNTPOINT = MOUNTS[FSNAME]
              if(! MOUNTPOINT)
                MOUNTPOINT = "-"
              printf "  %-" FSNAME_LENGTH "s %-6s %-" MOUNTPOINT_LENGTH "s %6s %s\n", FSNAME, ACTIVE, MOUNTPOINT, __show_units(SPACES[FSNAME]), __convert_date(CREATIONS[FSNAME])
              ORIGIN = ORIGINS[FSNAME]
              ORIGIN_DISPLAY = ORIGIN
              sub(BENAME_BEGINS_WITH "/", "", ORIGIN_DISPLAY)
              if(ORIGIN != "-") {
                if(OPTION_D == 1)
                  SPACE = REFER[ORIGIN]
                else
                  SPACE = SPACES[ORIGIN]
                printf  "  %-" FSNAME_LENGTH "s %-6s %-" MOUNTPOINT_LENGTH "s %6s %s\n", "  " ORIGIN_DISPLAY, "-", "-", __show_units(SPACE), __convert_date(CREATIONS[ORIGIN])
              }
            }
          }
        }
        else {
          SPACE = 0
          ACTIVE = __active(BENAME_BEGINS_WITH "/" BENAME)
          for(J = 1; J <= length(FSNAMES); J++) {
            FSNAME = FSNAMES[J]
            if(FSNAME ~ "^" BENAME_BEGINS_WITH "/" BENAME "(/[^@]*)?$") {
              if((BENAME_BEGINS_WITH "/" BENAME) == FSNAME) {
                MOUNTPOINT = MOUNTS[FSNAME]
                if(! MOUNTPOINT)
                  MOUNTPOINT = "-"
                CREATION = __convert_date(CREATIONS[FSNAME])
              }
              ORIGIN = ORIGINS[FSNAME]
              if(ORIGIN == "-")
                SPACE += SPACES[FSNAME]
              else {
                if(OPTION_D == 1)
                  SPACE += REFER[FSNAME]
                else
                  SPACE += SPACES[FSNAME] + SPACES[ORIGIN]
              }
            }
          }
          if(OPTION_H == 1)
            printf "%s\t%s\t%s\t%s\t%s\n", BENAME, ACTIVE, MOUNTPOINT, __show_units(SPACE), CREATION
          else
            printf "%-" FSNAME_LENGTH "s %-6s %-" MOUNTPOINT_LENGTH "s %6s %s\n", BENAME, ACTIVE, MOUNTPOINT, __show_units(SPACE), CREATION
        }
      }

    }'
  return 0
}

cmd_create() {
    local cc_clearsnap=0
    local cc_activate=0
    local cc_bename=${@:$#}
    
    while getopts "ae:" cc_pnam "$@"; do
        #echo "$cc_pnam: $OPTARG"
        case $cc_pnam in
            a) cc_activate=1 ;;
            e) cc_source=$OPTARG ;;
            *) return usage ;;
        esac
    done
}

cmd_destroy() {
  echo "Not Implemented"
  return 1
}

cmd_mount() {
  echo "Not Implemented"
  return 1
}

cmd_activate() {
  [ ${#} -eq 1 ] || return usage
  local be=$(get_bebase)/$1
  if ! be_exists $be; then
    echo "ERROR: Boot environment '$1' does not exist"
    return 1
  fi
  if ! zpool set bootfs=${be} ${POOL} 1> /dev/null 2> /dev/null;then
    echo "ERROR: Failed to activate '${1}' boot environment" >2
    return 1
  fi
  # execute ZFS LIST only once
  ZFS_LIST=$( zfs list -t filesystem -H -o name -r $(get_bebase) )
  # disable automatic mount on all inactive boot environments
  echo "${ZFS_LIST}" \
    | grep -v "^$(get_bebase)$" \
    | grep -v "^${be}$" \
    | grep -v "^${be}/" \
    | while read NAME; do
        zfs set canmount=noauto ${NAME}
      done
  echo "${ZFS_LIST}" \
    | grep -E "^${be}(/|$)" \
    | while read NAME; do
        zfs set canmount=on ${NAME}
        while be_isclone ${NAME};do
          zfs promote ${NAME}
        done
      done
  update_grub
  echo "Activated successfully"
  return 0
}

cmd_rename() {
  echo "Not Implemented"
  return 1
}

SUBCMD=$(get_command $1)
if [ $# -ne 0 ]; then shift; fi
CMDARGS="$@"
$SUBCMD $CMDARGS
